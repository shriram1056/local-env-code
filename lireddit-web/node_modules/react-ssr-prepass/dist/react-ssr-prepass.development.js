"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

var React = require("react");

var React__default = _interopDefault(React);

var is = require("react-is");

var is$1 = _interopDefault(require("object-is"));

function _extends() {
  return (_extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

var REACT_ELEMENT_TYPE = is.Element;

var REACT_PORTAL_TYPE = is.Portal;

var REACT_FRAGMENT_TYPE = is.Fragment;

var REACT_STRICT_MODE_TYPE = is.StrictMode;

var REACT_PROFILER_TYPE = is.Profiler;

var REACT_PROVIDER_TYPE = is.ContextProvider;

var REACT_CONTEXT_TYPE = is.ContextConsumer;

var REACT_CONCURRENT_MODE_TYPE = is.ConcurrentMode;

var REACT_FORWARD_REF_TYPE = is.ForwardRef;

var REACT_SUSPENSE_TYPE = is.Suspense;

var REACT_MEMO_TYPE = is.Memo;

var REACT_LAZY_TYPE = is.Lazy;

var toArray = React.Children.toArray;

var isAbstractElement = function(node) {
  return null !== node && "object" == typeof node;
};

var getChildrenArray = function(node) {
  return toArray(node).filter(isAbstractElement);
};

var computeProps = function(props, defaultProps) {
  return "object" == typeof defaultProps ? _extends({}, defaultProps, props) : props;
};

var currentContextStore = new Map;

var currentContextMap = {};

var prevContextMap = void 0;

var prevContextEntry = void 0;

var getCurrentContextMap = function() {
  return _extends({}, currentContextMap);
};

var getCurrentContextStore = function() {
  return new Map(currentContextStore);
};

var flushPrevContextMap = function() {
  var prev = prevContextMap;
  prevContextMap = void 0;
  return prev;
};

var flushPrevContextStore = function() {
  var prev = prevContextEntry;
  prevContextEntry = void 0;
  return prev;
};

var restoreContextMap = function(prev) {
  if (void 0 !== prev) {
    _extends(currentContextMap, prev);
  }
};

var restoreContextStore = function(prev) {
  if (void 0 !== prev) {
    currentContextStore.set(prev[0], prev[1]);
  }
};

var setCurrentContextMap = function(map) {
  prevContextMap = void 0;
  currentContextMap = map;
};

var setCurrentContextStore = function(store) {
  prevContextEntry = void 0;
  currentContextStore = store;
};

var readContextValue = function(context) {
  var value = currentContextStore.get(context);
  if (void 0 !== value) {
    return value;
  }
  return context._currentValue;
};

var emptyContext = {};

var maskContext = function(type) {
  var contextType = type.contextType;
  var contextTypes = type.contextTypes;
  if (contextType) {
    return readContextValue(contextType);
  } else if (!contextTypes) {
    return emptyContext;
  }
  var maskedContext = {};
  for (var name in contextTypes) {
    maskedContext[name] = currentContextMap[name];
  }
  return maskedContext;
};

var currentIdentity = null;

var setCurrentIdentity = function(id) {
  currentIdentity = id;
};

var getCurrentIdentity = function() {
  if (null === currentIdentity) {
    throw new Error("[react-ssr-prepass] Hooks can only be called inside the body of a function component. (https://fb.me/react-invalid-hook-call)");
  }
  return currentIdentity;
};

var firstWorkInProgressHook = null;

var workInProgressHook = null;

var didScheduleRenderPhaseUpdate = !1;

var renderPhaseUpdates = null;

var numberOfReRenders = 0;

var setFirstHook = function(hook) {
  firstWorkInProgressHook = hook;
};

function createWorkInProgressHook() {
  if (null === workInProgressHook) {
    if (null === firstWorkInProgressHook) {
      return firstWorkInProgressHook = workInProgressHook = {
        memoizedState: null,
        queue: null,
        next: null
      };
    } else {
      return workInProgressHook = firstWorkInProgressHook;
    }
  } else if (null === workInProgressHook.next) {
    return workInProgressHook = workInProgressHook.next = {
      memoizedState: null,
      queue: null,
      next: null
    };
  } else {
    return workInProgressHook = workInProgressHook.next;
  }
}

function basicStateReducer(state, action) {
  return "function" == typeof action ? action(state) : action;
}

function useReducer(reducer, initialArg, init) {
  var id = getCurrentIdentity();
  if (null === (workInProgressHook = createWorkInProgressHook()).queue) {
    var initialState;
    if (reducer === basicStateReducer) {
      initialState = "function" == typeof initialArg ? initialArg() : initialArg;
    } else {
      initialState = void 0 !== init ? init(initialArg) : initialArg;
    }
    workInProgressHook.memoizedState = initialState;
  }
  var queue = workInProgressHook.queue || (workInProgressHook.queue = {
    last: null,
    dispatch: null
  });
  var dispatch = queue.dispatch || (queue.dispatch = dispatchAction.bind(null, id, queue));
  if (null !== renderPhaseUpdates) {
    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
    if (void 0 !== firstRenderPhaseUpdate) {
      renderPhaseUpdates.delete(queue);
      var newState = workInProgressHook.memoizedState;
      var update = firstRenderPhaseUpdate;
      do {
        newState = reducer(newState, update.action);
        update = update.next;
      } while (null !== update);
      workInProgressHook.memoizedState = newState;
    }
  }
  return [ workInProgressHook.memoizedState, dispatch ];
}

function useMemo(nextCreate, deps) {
  getCurrentIdentity();
  var nextDeps = void 0 === deps ? null : deps;
  var prevState = (workInProgressHook = createWorkInProgressHook()).memoizedState;
  if (null !== prevState && null !== nextDeps) {
    if (function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) {
        return !1;
      }
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
        if (!is$1(nextDeps[i], prevDeps[i])) {
          return !1;
        }
      }
      return !0;
    }(nextDeps, prevState[1])) {
      return prevState[0];
    }
  }
  var nextValue = nextCreate();
  workInProgressHook.memoizedState = [ nextValue, nextDeps ];
  return nextValue;
}

function dispatchAction(componentIdentity, queue, action) {
  if (componentIdentity === currentIdentity) {
    didScheduleRenderPhaseUpdate = !0;
    var update = {
      action: action,
      next: null
    };
    if (null === renderPhaseUpdates) {
      renderPhaseUpdates = new Map;
    }
    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
    if (void 0 === firstRenderPhaseUpdate) {
      renderPhaseUpdates.set(queue, update);
    } else {
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
      while (null !== lastRenderPhaseUpdate.next) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }
      lastRenderPhaseUpdate.next = update;
    }
  }
}

function noop() {}

function _ref(callback) {
  callback();
}

var Dispatcher = {
  readContext: function readContext(context, _) {
    return readContextValue(context);
  },
  useContext: function useContext(context, _) {
    getCurrentIdentity();
    return readContextValue(context);
  },
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: function useRef(initialValue) {
    getCurrentIdentity();
    var previousRef = (workInProgressHook = createWorkInProgressHook()).memoizedState;
    if (null === previousRef) {
      var ref = {
        current: initialValue
      };
      workInProgressHook.memoizedState = ref;
      return ref;
    } else {
      return previousRef;
    }
  },
  useState: function useState(initialState) {
    return useReducer(basicStateReducer, initialState);
  },
  useCallback: function useCallback(callback, deps) {
    return useMemo((function() {
      return callback;
    }), deps);
  },
  useTransition: function useTransition() {
    return [ _ref, !1 ];
  },
  useDeferredValue: function useDeferredValue(input) {
    return input;
  },
  useLayoutEffect: noop,
  useImperativeHandle: noop,
  useEffect: noop,
  useDebugValue: noop
};

var resolve = function(type) {
  type._status = 0;
  return type._ctor().then((function(Component) {
    if ("function" == typeof Component) {
      type._result = Component;
      type._status = 1;
    } else if (null !== Component && "object" == typeof Component && "function" == typeof Component.default) {
      type._result = Component.default;
      type._status = 1;
    } else {
      type._status = 2;
    }
  })).catch((function() {
    type._status = 2;
  }));
};

var render = function(type, props, queue) {
  if (1 === type._status) {
    return React.createElement(type._result, props);
  }
  return null;
};

var makeFrame = function(type, props, thenable) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    id: getCurrentIdentity(),
    hook: firstWorkInProgressHook,
    kind: "frame.hooks",
    thenable: thenable,
    props: props,
    type: type
  };
};

var render$1 = function(type, props, queue) {
  try {
    return function renderWithHooks(Component, props, refOrContext) {
      workInProgressHook = null;
      var children = Component(props, refOrContext);
      while (numberOfReRenders < 25 && didScheduleRenderPhaseUpdate) {
        didScheduleRenderPhaseUpdate = !1;
        numberOfReRenders += 1;
        workInProgressHook = null;
        children = Component(props, refOrContext);
      }
      numberOfReRenders = 0;
      renderPhaseUpdates = null;
      workInProgressHook = null;
      return children;
    }(type, computeProps(props, type.defaultProps), maskContext(type));
  } catch (error) {
    if ("function" != typeof error.then) {
      throw error;
    }
    queue.push(makeFrame(type, props, error));
    return null;
  }
};

function _ref$1() {
  return !1;
}

function _ref2() {
  return null;
}

var createInstance = function(type, props) {
  var updater = {
    queue: queue = [],
    isMounted: _ref$1,
    enqueueForceUpdate: _ref2,
    enqueueReplaceState: function(instance, completeState) {
      if (instance._isMounted) {
        queue.length = 0;
        queue.push(completeState);
      }
    },
    enqueueSetState: function(instance, currentPartialState) {
      if (instance._isMounted) {
        queue.push(currentPartialState);
      }
    }
  };
  var queue;
  var computedProps = computeProps(props, type.defaultProps);
  var context = maskContext(type);
  var instance = new type(computedProps, context, updater);
  instance.props = computedProps;
  instance.context = context;
  instance.updater = updater;
  instance._isMounted = !0;
  if (void 0 === instance.state) {
    instance.state = null;
  }
  if ("function" == typeof type.getDerivedStateFromProps) {
    var state = (0, type.getDerivedStateFromProps)(instance.props, instance.state);
    if (null != state) {
      instance.state = _extends({}, instance.state, state);
    }
  } else if ("function" == typeof instance.componentWillMount) {
    instance.componentWillMount();
  } else if ("function" == typeof instance.UNSAFE_componentWillMount) {
    instance.UNSAFE_componentWillMount();
  }
  return instance;
};

var makeFrame$1 = function(type, instance, thenable) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    thenable: thenable,
    kind: "frame.class",
    instance: instance,
    type: type
  };
};

var render$2 = function(type, instance, queue) {
  !function(instance) {
    var queue = instance.updater.queue;
    if (queue.length > 0) {
      var nextState = _extends({}, instance.state);
      for (var i = 0, l = queue.length; i < l; i++) {
        var partial = queue[i];
        var partialState = "function" == typeof partial ? partial.call(instance, nextState, instance.props, instance.context) : partial;
        if (null !== partialState) {
          _extends(nextState, partialState);
        }
      }
      instance.state = nextState;
      queue.length = 0;
    }
  }(instance);
  var child = null;
  try {
    child = instance.render();
  } catch (error) {
    if ("function" != typeof error.then) {
      throw error;
    }
    queue.push(makeFrame$1(type, instance, error));
    return null;
  }
  if (void 0 !== type.childContextTypes && "function" == typeof instance.getChildContext) {
    var childContext = instance.getChildContext();
    if (null !== childContext && "object" == typeof childContext) {
      !function(map) {
        prevContextMap = {};
        for (var name in map) {
          prevContextMap[name] = currentContextMap[name];
          currentContextMap[name] = map[name];
        }
      }(childContext);
    }
  }
  if ("function" != typeof instance.getDerivedStateFromProps && ("function" == typeof instance.componentWillMount || "function" == typeof instance.UNSAFE_componentWillMount) && "function" == typeof instance.componentWillUnmount) {
    try {
      instance.componentWillUnmount();
    } catch (_err) {}
  }
  instance._isMounted = !1;
  return child;
};

var SHOULD_YIELD = "function" == typeof setImmediate;

var YIELD_AFTER_MS = "production" !== process.env.NODE_ENV ? 20 : 5;

var render$3 = function(type, props, queue, visitor, element) {
  return (Comp = type).prototype && Comp.prototype.isReactComponent ? function(type, props, queue, visitor, element) {
    setCurrentIdentity(null);
    var instance = createInstance(type, props);
    var promise = visitor(element, instance);
    if (promise) {
      queue.push(makeFrame$1(type, instance, promise));
      return null;
    }
    return render$2(type, instance, queue);
  }(type, props, queue, visitor, element) : function(type, props, queue, visitor, element) {
    setFirstHook(null);
    setCurrentIdentity({});
    var promise = visitor(element);
    if (promise) {
      queue.push(makeFrame(type, props, promise));
      return null;
    }
    return render$1(type, props, queue);
  }(type, props, queue, visitor, element);
  var Comp;
};

var visitElement = function(element, queue, visitor) {
  switch (function(x) {
    switch (x.$$typeof) {
     case REACT_PORTAL_TYPE:
      return REACT_PORTAL_TYPE;

     case REACT_ELEMENT_TYPE:
      switch (x.type) {
       case REACT_CONCURRENT_MODE_TYPE:
        return REACT_CONCURRENT_MODE_TYPE;

       case REACT_FRAGMENT_TYPE:
        return REACT_FRAGMENT_TYPE;

       case REACT_PROFILER_TYPE:
        return REACT_PROFILER_TYPE;

       case REACT_STRICT_MODE_TYPE:
        return REACT_STRICT_MODE_TYPE;

       case REACT_SUSPENSE_TYPE:
        return REACT_SUSPENSE_TYPE;

       default:
        switch (x.type && x.type.$$typeof) {
         case REACT_LAZY_TYPE:
          return REACT_LAZY_TYPE;

         case REACT_MEMO_TYPE:
          return REACT_MEMO_TYPE;

         case REACT_CONTEXT_TYPE:
          return REACT_CONTEXT_TYPE;

         case REACT_PROVIDER_TYPE:
          return REACT_PROVIDER_TYPE;

         case REACT_FORWARD_REF_TYPE:
          return REACT_FORWARD_REF_TYPE;

         default:
          return REACT_ELEMENT_TYPE;
        }
      }

     default:
      return;
    }
  }(element)) {
   case REACT_SUSPENSE_TYPE:
   case REACT_STRICT_MODE_TYPE:
   case REACT_CONCURRENT_MODE_TYPE:
   case REACT_PROFILER_TYPE:
   case REACT_FRAGMENT_TYPE:
    return getChildrenArray(element.props.children);

   case REACT_PROVIDER_TYPE:
    var ref = element.props;
    var children = ref.children;
    !function(context, value) {
      prevContextEntry = [ context, currentContextStore.get(context) ];
      currentContextStore.set(context, value);
    }(element.type._context, ref.value);
    return getChildrenArray(children);

   case REACT_CONTEXT_TYPE:
    var children$1 = element.props.children;
    if ("function" == typeof children$1) {
      var type = element.type;
      var value$1 = readContextValue("object" == typeof type._context ? type._context : type);
      return getChildrenArray(children$1(value$1));
    } else {
      return [];
    }

   case REACT_LAZY_TYPE:
    var child = function(type, props, queue) {
      if (2 !== type._status && 1 !== type._status) {
        queue.push({
          contextMap: getCurrentContextMap(),
          contextStore: getCurrentContextStore(),
          kind: "frame.lazy",
          thenable: resolve(type),
          props: props,
          type: type
        });
        return null;
      }
      return render(type, props);
    }(element.type, element.props, queue);
    return getChildrenArray(child);

   case REACT_MEMO_TYPE:
    var child$1 = React.createElement(element.type.type, element.props);
    return getChildrenArray(child$1);

   case REACT_FORWARD_REF_TYPE:
    var ref$3 = element.type;
    var type$3 = ref$3.render;
    var props = computeProps(element.props, ref$3.defaultProps);
    var child$2 = React.createElement(type$3, props);
    return getChildrenArray(child$2);

   case REACT_ELEMENT_TYPE:
    if ("string" == typeof element.type) {
      return getChildrenArray(element.props.children);
    } else {
      var child$3 = render$3(element.type, element.props, queue, visitor, element);
      return getChildrenArray(child$3);
    }

   case REACT_PORTAL_TYPE:
   default:
    return [];
  }
};

var visitLoop = function(traversalChildren, traversalMap, traversalStore, queue, visitor) {
  var start = Date.now();
  while (traversalChildren.length > 0) {
    var element = traversalChildren[traversalChildren.length - 1].shift();
    if (void 0 !== element) {
      var children = visitElement(element, queue, visitor);
      traversalChildren.push(children);
      traversalMap.push(flushPrevContextMap());
      traversalStore.push(flushPrevContextStore());
    } else {
      traversalChildren.pop();
      restoreContextMap(traversalMap.pop());
      restoreContextStore(traversalStore.pop());
    }
    if (SHOULD_YIELD && Date.now() - start > YIELD_AFTER_MS) {
      return !0;
    }
  }
  return !1;
};

var makeYieldFrame = function(traversalChildren, traversalMap, traversalStore) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    thenable: Promise.resolve(),
    kind: "frame.yield",
    children: traversalChildren,
    map: traversalMap,
    store: traversalStore
  };
};

var ReactCurrentDispatcher = React__default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;

function wrapWithDispatcher(exec) {
  return function() {
    var args = [], len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }
    var prevDispatcher = ReactCurrentDispatcher.current;
    try {
      ReactCurrentDispatcher.current = Dispatcher;
      return exec.apply(void 0, args);
    } finally {
      ReactCurrentDispatcher.current = prevDispatcher;
    }
  };
}

var resumeWithDispatcher = wrapWithDispatcher((function(frame, queue, visitor) {
  setCurrentIdentity(null);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  if (visitLoop(frame.children, frame.map, frame.store, queue, visitor)) {
    queue.unshift(makeYieldFrame(frame.children, frame.map, frame.store));
  }
}));

var visitWithDispatcher = wrapWithDispatcher((function(init, queue, visitor) {
  var traversalChildren = [ init ];
  var traversalMap = [ flushPrevContextMap() ];
  var traversalStore = [ flushPrevContextStore() ];
  if (visitLoop(traversalChildren, traversalMap, traversalStore, queue, visitor)) {
    queue.unshift(makeYieldFrame(traversalChildren, traversalMap, traversalStore));
  }
}));

var updateWithDispatcher = wrapWithDispatcher((function(frame, queue) {
  switch (frame.kind) {
   case "frame.class":
    return function(queue, frame) {
      setCurrentIdentity(null);
      setCurrentContextMap(frame.contextMap);
      setCurrentContextStore(frame.contextStore);
      return render$2(frame.type, frame.instance, queue);
    }(queue, frame);

   case "frame.hooks":
    return function(queue, frame) {
      setFirstHook(frame.hook);
      setCurrentIdentity(frame.id);
      setCurrentContextMap(frame.contextMap);
      setCurrentContextStore(frame.contextStore);
      return render$1(frame.type, frame.props, queue);
    }(queue, frame);

   case "frame.lazy":
    return function(queue, frame) {
      setCurrentIdentity(null);
      setCurrentContextMap(frame.contextMap);
      setCurrentContextStore(frame.contextStore);
      return render(frame.type, frame.props);
    }(0, frame);

   default:
    return [];
  }
}));

var flushFrames = function(queue, visitor) {
  var frame = queue.shift();
  return frame ? function(frame, queue, visitor) {
    if ("frame.yield" === frame.kind) {
      return new Promise((function _ref(resolve, reject) {
        var resume = function() {
          try {
            resumeWithDispatcher(frame, queue, visitor);
            resolve();
          } catch (err) {
            reject(err);
          }
        };
        if (SHOULD_YIELD) {
          setImmediate(resume);
        } else {
          resume();
        }
      }));
    }
    return frame.thenable.then((function() {
      var children = updateWithDispatcher(frame, queue);
      visitWithDispatcher(getChildrenArray(children), queue, visitor);
    }));
  }(frame, queue, visitor).then((function() {
    return flushFrames(queue, visitor);
  })) : Promise.resolve();
};

var defaultVisitor = function() {
  return;
};

module.exports = function(element, visitor) {
  var queue = [];
  var fn = void 0 !== visitor ? visitor : defaultVisitor;
  setCurrentContextMap({});
  setCurrentContextStore(new Map);
  try {
    visitWithDispatcher(getChildrenArray(element), queue, fn);
  } catch (error) {
    return Promise.reject(error);
  }
  return flushFrames(queue, fn);
};
//# sourceMappingURL=react-ssr-prepass.development.js.map
