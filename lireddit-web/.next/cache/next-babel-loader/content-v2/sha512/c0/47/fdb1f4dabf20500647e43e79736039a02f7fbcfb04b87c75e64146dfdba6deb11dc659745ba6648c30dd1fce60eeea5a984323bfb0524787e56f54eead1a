{"ast":null,"code":"import _toConsumableArray from \"/home/shriram/Downloads/lireddit/lireddit-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/home/shriram/Downloads/lireddit/lireddit-web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n// this import is for forwarding the cookie\nimport { createWithApollo } from './createWithApollo';\n\nvar createClient = function createClient(ctx) {\n  var _ctx$req;\n\n  return new ApolloClient({\n    uri: 'http://localhost:4000/graphql',\n    credentials: 'include',\n    headers: {\n      cookie: (false ? ctx === null || ctx === void 0 ? void 0 : (_ctx$req = ctx.req) === null || _ctx$req === void 0 ? void 0 : _ctx$req.headers.cookie : undefined) || ''\n    },\n    cache: new InMemoryCache({\n      typePolicies: {\n        Query: {\n          fields: {\n            posts: {\n              keyArgs: [],\n              merge: function merge(existing, incoming) {\n                return _objectSpread(_objectSpread({}, incoming), {}, {\n                  posts: [].concat(_toConsumableArray((existing === null || existing === void 0 ? void 0 : existing.posts) || []), _toConsumableArray(incoming.posts))\n                });\n              }\n            }\n          }\n        }\n      }\n    })\n  });\n};\n\nexport var withApollo = createWithApollo(createClient); //keyArgs - []: Specifying this array can help reduce the amount of duplicate data in your cache.\n//By default, the cache stores a separate value for every unique combination of argument values you provide when querying a particular field. When you specify a field's key arguments, the cache understands that any non-key arguments don't affect that field's value\n// Consequently, if you execute two different queries with the monthForNumber field, passing the same number argument but different accessToken arguments, the second query response will overwrite the first, because both invocations use the exact same value for all key arguments.","map":{"version":3,"sources":["/home/shriram/Downloads/lireddit/lireddit-web/src/utils/withApollo.ts"],"names":["ApolloClient","InMemoryCache","createWithApollo","createClient","ctx","uri","credentials","headers","cookie","req","undefined","cache","typePolicies","Query","fields","posts","keyArgs","merge","existing","incoming","withApollo"],"mappings":";;;;;;;AAAA,SAASA,YAAT,EAAuBC,aAAvB,QAA4C,gBAA5C;AAGA;AACA,SAASC,gBAAT,QAAiC,oBAAjC;;AAEA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,GAAD;AAAA;;AAAA,SACnB,IAAIJ,YAAJ,CAAiB;AACfK,IAAAA,GAAG,EAAE,+BADU;AAEfC,IAAAA,WAAW,EAAE,SAFE;AAGfC,IAAAA,OAAO,EAAE;AACPC,MAAAA,MAAM,EACJ,CAAC,QACGJ,GADH,aACGA,GADH,mCACGA,GAAG,CAAEK,GADR,6CACG,SAAUF,OAAV,CAAkBC,MADrB,GAEGE,SAFJ,KAEkB;AAJb,KAHM;AASfC,IAAAA,KAAK,EAAE,IAAIV,aAAJ,CAAkB;AACvBW,MAAAA,YAAY,EAAE;AACZC,QAAAA,KAAK,EAAE;AACLC,UAAAA,MAAM,EAAE;AACNC,YAAAA,KAAK,EAAE;AACLC,cAAAA,OAAO,EAAE,EADJ;AAELC,cAAAA,KAFK,iBAGHC,QAHG,EAIHC,QAJG,EAKa;AAChB,uDACKA,QADL;AAEEJ,kBAAAA,KAAK,+BAAO,CAAAG,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAEH,KAAV,KAAmB,EAA1B,sBAAkCI,QAAQ,CAACJ,KAA3C;AAFP;AAID;AAVI;AADD;AADH;AADK;AADS,KAAlB;AATQ,GAAjB,CADmB;AAAA,CAArB;;AAgCA,OAAO,IAAMK,UAAU,GAAGlB,gBAAgB,CAACC,YAAD,CAAnC,C,CACP;AAEA;AACA","sourcesContent":["import { ApolloClient, InMemoryCache } from '@apollo/client'\nimport { NextPageContext } from 'next'\nimport { PaginatedPosts } from '../generated/graphql'\n// this import is for forwarding the cookie\nimport { createWithApollo } from './createWithApollo'\n\nconst createClient = (ctx: NextPageContext) =>\n  new ApolloClient({\n    uri: 'http://localhost:4000/graphql',\n    credentials: 'include',\n    headers: {\n      cookie:\n        (typeof window === 'undefined'\n          ? ctx?.req?.headers.cookie\n          : undefined) || '',\n    },\n    cache: new InMemoryCache({\n      typePolicies: {\n        Query: {\n          fields: {\n            posts: {\n              keyArgs: [],\n              merge(\n                existing: PaginatedPosts | undefined,\n                incoming: PaginatedPosts\n              ): PaginatedPosts {\n                return {\n                  ...incoming,\n                  posts: [...(existing?.posts || []), ...incoming.posts],\n                }\n              },\n            },\n          },\n        },\n      },\n    }),\n  })\n\nexport const withApollo = createWithApollo(createClient)\n//keyArgs - []: Specifying this array can help reduce the amount of duplicate data in your cache.\n\n//By default, the cache stores a separate value for every unique combination of argument values you provide when querying a particular field. When you specify a field's key arguments, the cache understands that any non-key arguments don't affect that field's value\n// Consequently, if you execute two different queries with the monthForNumber field, passing the same number argument but different accessToken arguments, the second query response will overwrite the first, because both invocations use the exact same value for all key arguments.\n"]},"metadata":{},"sourceType":"module"}